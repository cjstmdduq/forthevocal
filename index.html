<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>í¬ë”ë³´ì»¬ - ë°œì„± ì‹œê°í™” ë„êµ¬</title>
  <style>
    :root {
      --primary-color: #4e54c8;
      --secondary-color: #8f94fb;
      --accent-color: #ff6b6b;
      --background-color: #f9f9f9;
      --panel-color: #ffffff;
      --text-color: #333333;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Noto Sans KR', sans-serif;
      background: var(--background-color);
      color: var(--text-color);
      line-height: 1.6;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      min-height: 100vh;
    }

    header {
      width: 100%;
      max-width: 1000px;
      margin-bottom: 20px;
      text-align: center;
    }

    /* ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    h1 {
      font-size: 2.8rem;
      margin-bottom: 15px;
      background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      font-weight: 800;
      letter-spacing: -0.5px;
      text-shadow: 0 2px 10px rgba(78, 84, 200, 0.15);
      animation: fadeIn 0.8s ease-out;
    }

    .subtitle {
      font-size: 1.2rem;
      color: #555;
      margin-bottom: 25px;
      font-weight: 500;
      opacity: 0.9;
      animation: fadeIn 0.8s ease-out 0.2s backwards;
    }

    .container {
      display: flex;
      width: 100%;
      max-width: 1200px;
      gap: 30px;
      transition: all 0.2s ease;
      align-items: flex-start;
    }

    .tools-panel {
      flex: 0 0 300px;
      background: var(--panel-color);
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .tool-section {
      border-bottom: 1px solid #eee;
      padding-bottom: 15px;
    }

    .tool-section:last-child {
      border-bottom: none;
    }

    .section-title {
      font-size: 1.2rem;
      font-weight: 700;
      margin-bottom: 15px;
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-title i {
      font-size: 1.4rem;
    }

    .drawing-tools {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }

    .tool-btn {
      padding: 8px;
      border: 2px solid transparent;
      border-radius: 8px;
      background: #f0f0f0;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 0.9rem;
    }

    .tool-btn i {
      font-size: 1.5rem;
      margin-bottom: 5px;
    }

    .tool-btn:hover {
      background: #e8e8e8;
    }

    .tool-btn.active {
      border-color: var(--primary-color);
      background: rgba(78, 84, 200, 0.1);
    }

    .color-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .color-option {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #eee;
      transition: transform 0.2s;
    }

    .color-option:hover {
      transform: scale(1.15);
    }

    .color-option.active {
      border: 2px solid #333;
      transform: scale(1.15);
    }

    .slider-control {
      margin: 15px 0;
    }

    .slider-control label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .slider-container input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
    }

    .slider-container input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary-color);
      cursor: pointer;
    }

    .slider-value {
      font-weight: 500;
      min-width: 30px;
      text-align: center;
    }

    select {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #f9f9f9;
      font-size: 1rem;
      cursor: pointer;
    }
    
    small {
      display: block;
      font-size: 0.8rem;
      color: #666;
      margin-top: 3px;
      margin-bottom: 8px;
    }

    .vocal-element {
      margin-top: 10px;
    }

    .vocal-element label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }

    .canvas-container {
      flex: 1;
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      aspect-ratio: 1 / 1;
      width: 100%;
      max-width: 600px;
      max-height: 600px;
      margin: 0 auto;
    }
    
    /* ëª¨ë°”ì¼ì—ì„œ ìº ë²„ìŠ¤ êµ¬ì²´ì  ì¡°ì • */
    @media (max-width: 768px) {
      .canvas-container {
        aspect-ratio: 1/1;
        width: 100%;
        max-width: 100%;
        height: auto !important; /* ë†’ì´ ê°•ì œ ì ìš© */
        overflow: hidden;
        margin: 0 auto 20px auto;
        border-radius: 8px;
      }

      #vocalCanvas {
        width: 100% !important;
        height: 100% !important;
        object-fit: contain;
      }
      
      /* ìƒí™© ëª…ì¹­ í‘œì‹œ ëª¨ë°”ì¼ ì¡°ì • */
      .situation-display {
        font-size: 0.9rem;
        padding: 5px 10px;
        top: 5px;
        right: 5px;
      }
      
      /* ëª¨ë°”ì¼ì—ì„œ ë“œë¡­ë‹¤ìš´ ì»¨íŠ¸ë¡¤ ìµœì í™” */
      select {
        height: 44px;
        font-size: 1.1rem;
        background-color: #f0f0f0;
        border: 1px solid #ddd;
        margin-bottom: 10px;
        -webkit-appearance: none;
        background-image: url("data:image/svg+xml;utf8,<svg fill='black' height='24' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>");
        background-repeat: no-repeat;
        background-position: right 8px center;
        border-radius: 8px;
        padding: 0 12px;
      }
    }
    
    @media (min-width: 1200px) {
      .canvas-container {
        aspect-ratio: auto;
        min-height: 650px;
      }
    }
    
    /* ìƒí™© ëª…ì¹­ í‘œì‹œ ì—…ë°ì´íŠ¸ - ëª¨ë°”ì¼ì—ì„œë„ ì˜ ë³´ì´ê²Œ */
    .situation-display {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-weight: bold;
      z-index: 100;
      max-width: 80%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-size: 1rem;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    
    #vocalCanvas {
      display: block;
      background: #fcfcfc;
      cursor: crosshair;
      width: 100%;
      height: 100%;
      border-radius: 12px;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
    }

    .action-bar {
      width: 100%;
      max-width: 1200px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn-primary {
      background: var(--primary-color);
      color: white;
    }

    .btn-secondary {
      background: #e9ecef;
      color: #212529;
    }

    .btn-danger {
      background: var(--accent-color);
      color: white;
    }

    .btn:hover {
      opacity: 0.9;
      transform: translateY(-2px);
    }

    .memo-container {
      margin-top: 10px;
    }
    
    .memo-container label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    .memo-container textarea {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ddd;
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
      background-color: #f8f8f8;
      white-space: pre-line; /* ì¤„ë°”ê¿ˆ ì ìš© */
      line-height: 1.5;
    }
    
    .memo-container input[type="text"] {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ddd;
      resize: vertical;
      min-height: auto;
      height: 40px;
      font-family: inherit;
      background-color: #f8f8f8;
    }

    /* ëª¨ë°”ì¼ í† ê¸€ ë²„íŠ¼ */
    .mobile-toggle-btn {
      display: none;
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 200;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: transform 0.3s ease, background-color 0.3s ease;
    }
    
    .mobile-toggle-btn:active {
      transform: scale(0.9);
      background-color: var(--secondary-color);
    }
    
    /* ìº”ë²„ìŠ¤ í™•ëŒ€ ì• ë‹ˆë©”ì´ì…˜ */
    .canvas-container {
      transition: all 0.3s ease;
    }
    
    /* ì „ì²´í™”ë©´ ê´€ë ¨ ìŠ¤íƒ€ì¼ */
    .fullscreen-mode .canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      border-radius: 0;
    }
    
    .fullscreen-mode .tools-panel,
    .fullscreen-mode header,
    .fullscreen-mode .action-bar {
      display: none;
    }
    
    .fullscreen-mode .exit-fullscreen {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 1001;
    }
    
    /* ëª¨ë°”ì¼ ë°˜ì‘í˜• */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      h1 {
        font-size: 1.8rem;
        margin-bottom: 5px;
      }
      
      .subtitle {
        font-size: 0.9rem;
        margin-bottom: 10px;
      }
      
      header {
        margin-bottom: 10px;
        position: relative;
      }
      
      .mobile-toggle-btn {
        display: flex;
      }
      
      .tools-panel.collapsed {
        display: none;
      }
      
      .container {
        flex-direction: column;
        gap: 10px;
      }
      
      .tools-panel {
        flex: none;
        width: 100%;
        padding: 15px;
        max-height: 60vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      .tool-section {
        padding-bottom: 10px;
        margin-bottom: 10px;
      }
      
      .drawing-tools {
        grid-template-columns: repeat(4, 1fr);
      }
      
      .tool-btn {
        padding: 6px;
      }
      
      .tool-btn i {
        font-size: 1.2rem;
        margin-bottom: 2px;
      }
      
      .tool-btn span {
        font-size: 0.7rem;
      }
      
      .color-option {
        width: 25px;
        height: 25px;
      }
      
      .section-title {
        font-size: 1rem;
        margin-bottom: 10px;
      }
      
      .canvas-container {
        width: 100%;
        aspect-ratio: 1 / 1;
        height: auto !important;
        max-width: 90vw;
        margin: 0 auto 20px auto;
      }
      
      #vocalCanvas {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      
      .slider-container input[type="range"] {
        height: 10px;
      }
      
      .slider-container input[type="range"]::-webkit-slider-thumb {
        width: 22px;
        height: 22px;
      }
      
      .action-bar {
        flex-wrap: wrap;
        justify-content: space-between;
      }
      
      .btn {
        padding: 8px 12px;
        font-size: 0.9rem;
        margin-bottom: 5px;
        flex: 1 0 45%;
        justify-content: center;
      }
    }
    
    /* ìŠ¤í¬ë¡¤ ìŠ¤íƒ€ì¼ ê°œì„  */
    .tools-panel::-webkit-scrollbar {
      width: 8px;
    }
    
    .tools-panel::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }
    
    .tools-panel::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    
    .tools-panel::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    
    /* PC ë ˆì´ì•„ì›ƒ êµ¬ì²´ì  ì¡°ì • */
    @media (min-width: 992px) {
      .container {
        align-items: flex-start;
        justify-content: space-between;
        flex-wrap: nowrap;
      }
      
      .tools-panel {
        flex: 0 0 340px;
        padding: 25px;
        position: sticky;
        top: 20px;
        max-height: calc(100vh - 180px);
        overflow-y: auto;
      }
      
      .canvas-container {
        flex: 1;
        max-width: none;
        height: auto;
        min-height: 700px;
        margin-left: 20px;
        aspect-ratio: 1/1;
        max-width: 800px;
      }
      
      .action-bar {
        padding: 0 20px;
      }
    }
    
    /* ì‘ì€ ëª¨ë°”ì¼ í™”ë©´ */
    @media (max-width: 480px) {
      h1 {
        font-size: 1.5rem;
      }
      
      .drawing-tools {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .tool-btn {
        padding: 10px;
      }
      
      .tool-btn i {
        font-size: 1.4rem;
      }
      
      .color-picker {
        justify-content: center;
      }
      
      .canvas-container {
        aspect-ratio: 1/1;
        width: 100%;
        max-width: 100%;
      }
      
      .btn {
        font-size: 0.8rem;
        padding: 8px 10px;
      }
      
      .btn i {
        font-size: 1.2rem;
      }
    }

    /* ì•„ì´ì½˜ ìŠ¤íƒ€ì¼ */
    .material-icons {
      font-family: 'Material Icons';
      font-weight: normal;
      font-style: normal;
      font-size: 24px;
      line-height: 1;
      letter-spacing: normal;
      text-transform: none;
      display: inline-block;
      white-space: nowrap;
      word-wrap: normal;
      direction: ltr;
      -webkit-font-feature-settings: 'liga';
      -webkit-font-smoothing: antialiased;
    }
  </style>
  <!-- êµ¬ê¸€ í°íŠ¸ ë° ì•„ì´ì½˜ -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
  <header>
    <h1>ğŸµ í¬ë”ë³´ì»¬: ë°œì„± ì‹œê°í™” ë„êµ¬</h1>
    <p class="subtitle">ë°œì„± ì—°ìŠµì„ ìœ„í•œ ì‹œê°ì  ê°€ì´ë“œ ì—ë””í„°</p>
    <button class="mobile-toggle-btn" id="toggle-panel-btn">
      <i class="material-icons">menu</i>
    </button>
  </header>

  <div class="container">
    <div class="tools-panel">
      <div class="tool-section">
        <div class="section-title">
          <i class="material-icons">brush</i>
          <span>ê·¸ë¦¬ê¸° ë„êµ¬</span>
        </div>
        <div class="drawing-tools">
          <button class="tool-btn active" id="pencil-tool">
            <i class="material-icons">edit</i>
            <span>ì—°í•„</span>
          </button>
          <button class="tool-btn" id="line-tool">
            <i class="material-icons">show_chart</i>
            <span>ì§ì„ </span>
          </button>
          <button class="tool-btn" id="curve-tool">
            <i class="material-icons">timeline</i>
            <span>ê³¡ì„ </span>
          </button>
          <button class="tool-btn" id="arrow-tool">
            <i class="material-icons">arrow_forward</i>
            <span>í™”ì‚´í‘œ</span>
          </button>
        </div>
      </div>

      <div class="tool-section">
        <div class="section-title">
          <i class="material-icons">palette</i>
          <span>ìƒ‰ìƒ</span>
        </div>
        <div class="color-picker">
          <div class="color-option active" style="background-color: #ff6b6b;" data-color="#ff6b6b"></div>
          <div class="color-option" style="background-color: #4e54c8;" data-color="#4e54c8"></div>
          <div class="color-option" style="background-color: #38d9a9;" data-color="#38d9a9"></div>
          <div class="color-option" style="background-color: #ffd43b;" data-color="#ffd43b"></div>
          <div class="color-option" style="background-color: #000000;" data-color="#000000"></div>
        </div>
      </div>

      <div class="tool-section">
        <div class="section-title">
          <i class="material-icons">category</i>
          <span>ë°°ê²½ ì´ë¯¸ì§€</span>
        </div>

        <div class="vocal-element">
          <label for="background-image">ë°°ê²½ ì„ íƒ</label>
          <select id="background-image">
            <option value="none">ì—†ìŒ</option>
            <option value="vocal_cords">ì„±ëŒ€ (ì •ë©´ë„)</option>
            <option value="facial_view">ë°œì„±ê¸°ê´€ (ì¸¡ë©´ë„)</option>
            <option value="full_body_view">í˜¸í¡ê¸°ê´€ (ì „ì‹ ë„)</option>
            <option value="human_vocal">ì´ì „ ë°°ê²½ (ì°©ìš© ì˜ˆì •)</option>
          </select>
        </div>
        
        <div class="memo-container">
          <label for="situation-title">ì£¼ì œ ì…ë ¥</label>
          <input type="text" id="situation-title" class="memo-input" placeholder="ì£¼ì œë¥¼ ì…ë ¥í•˜ì„¸ìš”" />
          <small>ì´ë¯¸ì§€ ìš°ì¸¡ ìƒë‹¨ì— í‘œê¸°ë©ë‹ˆë‹¤</small>
        </div>

        <div class="memo-container">
          <label for="memo">ë©”ëª¨</label>
          <textarea id="memo" placeholder="ë°œì„± í…Œí¬ë‹‰ì´ë‚˜ ê´€ì°°ì‚¬í•­ì„ ì—¬ê¸°ì— ë©”ëª¨í•˜ì„¸ìš”.
ì¤„ë°”ê¿ˆì„ ì‚¬ìš©í•´ ì—¬ëŸ¬ ì¤„ë¡œ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."></textarea>
        </div>
      </div>
    </div>

    <div class="canvas-container">
      <div class="situation-display" id="situation-display"></div>
      <canvas id="vocalCanvas" width="800" height="600"></canvas>
    </div>
  </div>

  <div class="action-bar">
    <button class="btn btn-danger" id="clear-btn">
      <i class="material-icons">delete</i>
      <span>ì§€ìš°ê¸°</span>
    </button>
    <button class="btn btn-secondary" id="undo-btn">
      <i class="material-icons">undo</i>
      <span>ì‹¤í–‰ì·¨ì†Œ</span>
    </button>
    <button class="btn btn-secondary" id="download-img-btn">
      <i class="material-icons">image</i>
      <span>ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ</span>
    </button>
    <button class="btn btn-primary" id="save-btn">
      <i class="material-icons">save</i>
      <span>ì €ì¥í•˜ê¸°</span>
    </button>
    <button class="btn btn-secondary" id="fullscreen-btn">
      <i class="material-icons">fullscreen</i>
      <span>ì „ì²´í™”ë©´</span>
    </button>
  </div>

  <script>
    // ìº”ë²„ìŠ¤ ë° ì»¨í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
    const canvas = document.getElementById('vocalCanvas');
    const ctx = canvas.getContext('2d');
    
    // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
    function resizeCanvas() {
      const container = document.querySelector('.canvas-container');
      const devicePixelRatio = window.devicePixelRatio || 1;
      
      // ìº”ë²„ìŠ¤ ë””ìŠ¤í”Œë ˆì´ í¬ê¸° ì„¤ì •
      canvas.style.width = container.clientWidth + 'px';
      canvas.style.height = container.clientHeight + 'px';
      
      // ìº”ë²„ìŠ¤ ë²„í¼ í¬ê¸° ì„¤ì • (ë” ì„ ëª…í•œ í™”ì§ˆì„ ìœ„í•´)
      canvas.width = container.clientWidth * devicePixelRatio;
      canvas.height = container.clientHeight * devicePixelRatio;
      
      // ì»¨í…ìŠ¤íŠ¸ ìŠ¤ì¼€ì¼ ì¡°ì •
      ctx.scale(devicePixelRatio, devicePixelRatio);
      
      redrawCanvas();
    }

    // ì´ë¯¸ì§€ ë°°ê²½
    const backgroundImages = {
      none: null,
      human_vocal: 'human_vocal.png', 
      vocal_cords: 'vocal cords.png',
      facial_view: 'Vocal Anatomy â€“ Facial View.png',
      full_body_view: 'Vocal Anatomy â€“ Full-body View.png'
    };
    
    // ë°°ê²½ ì´ë¯¸ì§€ ê°ì²´
    const bgImg = new Image();
    
    // ìƒíƒœ ë³€ìˆ˜
    let isDrawing = false;
    let currentTool = 'pencil-tool';
    let currentColor = '#ff6b6b';
    let currentLineWidth = 1; // ê³ ì • 1px ì„  êµµê¸° ì‚¬ìš©
    let currentBackground = 'none';
    let currentSituation = '';
    let startX, startY;
    let points = []; // ê³¡ì„ ì„ ìœ„í•œ ì ë“¤
    let drawingHistory = [];
    let currentDrawingState = null;
    
    // ì „ì²´í™”ë©´ ëª¨ë“œ í† ê¸€
    let isFullscreen = false;
    
    function toggleFullscreen() {
      const body = document.body;
      
      if (!isFullscreen) {
        // ì „ì²´í™”ë©´ ëª¨ë“œ ì¼œê¸°
        body.classList.add('fullscreen-mode');
        
        // ì „ì²´í™”ë©´ ë‚˜ê°€ê¸° ë²„íŠ¼ ì¶”ê°€
        const exitBtn = document.createElement('button');
        exitBtn.className = 'exit-fullscreen';
        exitBtn.innerHTML = '<i class="material-icons">fullscreen_exit</i>';
        exitBtn.addEventListener('click', toggleFullscreen);
        document.body.appendChild(exitBtn);
        
        isFullscreen = true;
      } else {
        // ì „ì²´í™”ë©´ ëª¨ë“œ ë„ê¸°
        body.classList.remove('fullscreen-mode');
        
        // ì „ì²´í™”ë©´ ë‚˜ê°€ê¸° ë²„íŠ¼ ì œê±°
        const exitBtn = document.querySelector('.exit-fullscreen');
        if (exitBtn) exitBtn.remove();
        
        isFullscreen = false;
      }
      
      // ìº”ë²„ìŠ¤ í¬ê¸° ë‹¤ì‹œ ê³„ì‚°
      setTimeout(resizeCanvas, 100);
    }
    
    // ëª¨ë°”ì¼ì—ì„œ ë„êµ¬ íŒ¨ë„ í† ê¸€
    function toggleToolsPanel() {
      const toolsPanel = document.querySelector('.tools-panel');
      const toggleBtn = document.getElementById('toggle-panel-btn');
      toolsPanel.classList.toggle('collapsed');
      
      // ì•„ì´ì½˜ ë³€ê²½
      if (toolsPanel.classList.contains('collapsed')) {
        toggleBtn.querySelector('i').textContent = 'menu';
      } else {
        toggleBtn.querySelector('i').textContent = 'close';
      }
      
      // í† ê¸€ í›„ ìº”ë²„ìŠ¤ í¬ê¸° ë‹¤ì‹œ ê³„ì‚°
      setTimeout(resizeCanvas, 100);
    }
    
    // ì´ˆê¸°í™” í•¨ìˆ˜
    function init() {
      resizeCanvas();
      
      // íˆ´ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelector('.tool-btn.active').classList.remove('active');
          this.classList.add('active');
          currentTool = this.id;
        });
      });
      
      // ìƒ‰ìƒ ì„ íƒ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.querySelectorAll('.color-option').forEach(color => {
        color.addEventListener('click', function() {
          document.querySelector('.color-option.active').classList.remove('active');
          this.classList.add('active');
          currentColor = this.dataset.color;
        });
      });
      
    // ì„  êµµê¸° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° (ê³ ì • 1px ì‚¬ìš©)
      // ë°°ê²½ ì´ë¯¸ì§€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.getElementById('background-image').addEventListener('change', function() {
        currentBackground = this.value;
        if (backgroundImages[currentBackground]) {
          console.log('ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ ì‹œë„:', backgroundImages[currentBackground]);
          bgImg.src = backgroundImages[currentBackground];
          bgImg.onload = function() {
            console.log('ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ');
            redrawCanvas();
          };
          bgImg.onerror = function() {
            console.error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', backgroundImages[currentBackground]);
          };
        } else {
          redrawCanvas();
        }
      });
      
      // ìƒí™© ëª…ì¹­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.getElementById('situation-title').addEventListener('input', function() {
        currentSituation = this.value;
        updateSituationDisplay();
      });
      
      // ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.getElementById('clear-btn').addEventListener('click', clearCanvas);
      document.getElementById('undo-btn').addEventListener('click', undoLastAction);
      document.getElementById('save-btn').addEventListener('click', saveCanvas);
      document.getElementById('download-img-btn').addEventListener('click', downloadCanvasImage);
      document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
      document.getElementById('toggle-panel-btn').addEventListener('click', toggleToolsPanel);
      
      // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('mouseout', handleMouseOut);
      
      // í„°ì¹˜ ì´ë²¤íŠ¸ ì§€ì›
      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
      
      // í•€ì¹˜ ì¤Œ ë°©ì§€ (iOS Safari)
      document.addEventListener('gesturestart', function(e) {
        if (e.cancelable) e.preventDefault();
      }, { passive: false });
      document.addEventListener('gesturechange', function(e) {
        if (e.cancelable) e.preventDefault();
      }, { passive: false });
      
      // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸
      window.addEventListener('resize', resizeCanvas);
      
      // ì´ˆê¸° ìº”ë²„ìŠ¤ ì„¤ì •
      clearCanvas();
    }
    
    // ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // ë°°ê²½ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° - ë¹„ìœ¨ ìœ ì§€
      if (backgroundImages[currentBackground] && bgImg.complete) {
        const imgRatio = bgImg.width / bgImg.height;
        const canvasRatio = canvas.width / canvas.height;
        
        let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
        
        if (imgRatio > canvasRatio) {
          // ì´ë¯¸ì§€ê°€ ìº”ë²„ìŠ¤ë³´ë‹¤ ë” ê°€ë¡œë¡œ ê¸´ ê²½ìš°
          drawHeight = canvas.height;
          drawWidth = drawHeight * imgRatio;
          offsetX = (canvas.width - drawWidth) / 2;
        } else {
          // ì´ë¯¸ì§€ê°€ ìº”ë²„ìŠ¤ë³´ë‹¤ ë” ì„¸ë¡œë¡œ ê¸´ ê²½ìš°
          drawWidth = canvas.width;
          drawHeight = drawWidth / imgRatio;
          offsetY = (canvas.height - drawHeight) / 2;
        }
        
        ctx.drawImage(bgImg, offsetX, offsetY, drawWidth, drawHeight);
      }
      
      // ê·¸ë¦¬ê¸° íˆìŠ¤í† ë¦¬ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
      drawingHistory.forEach(state => {
        drawFromState(state);
      });
      
      // ìƒí™© ëª…ì¹­ í‘œì‹œ ì—…ë°ì´íŠ¸
      updateSituationDisplay();
    }
    
    // ìƒí™© ëª…ì¹­ í‘œì‹œ ì—…ë°ì´íŠ¸
    function updateSituationDisplay() {
      const situationDisplay = document.getElementById('situation-display');
      if (currentSituation) {
        situationDisplay.textContent = currentSituation;
        situationDisplay.style.display = 'block';
      } else {
        situationDisplay.style.display = 'none';
      }
    }
    
    // ìƒíƒœì—ì„œ ê·¸ë¦¬ê¸°
    function drawFromState(state) {
      const { type, color, lineWidth, points, memo } = state;
      
      // í°ìƒ‰ í…Œë‘ë¦¬ë¥¼ ìœ„í•œ ì„¤ì •
      function drawWithWhiteOutline(drawFunction) {
        // ë¨¼ì € í°ìƒ‰ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = 'white';
        ctx.lineWidth = lineWidth + 2; // í…Œë‘ë¦¬ êµµê¸° ê°ì†Œ
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        drawFunction();
        
        // ê·¸ ìœ„ì— ì‹¤ì œ ìƒ‰ìƒìœ¼ë¡œ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        drawFunction();
      }
      
      switch (type) {
        case 'pencil-tool':
          drawWithWhiteOutline(() => {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
              ctx.lineTo(points[i].x, points[i].y);
            }
            
            ctx.stroke();
          });
          break;
          
        case 'line-tool':
          drawWithWhiteOutline(() => {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[1].x, points[1].y);
            ctx.stroke();
          });
          break;
          
        case 'curve-tool':
          drawWithWhiteOutline(() => {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length - 2; i++) {
              const xc = (points[i].x + points[i + 1].x) / 2;
              const yc = (points[i].y + points[i + 1].y) / 2;
              ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
            }
            
            if (points.length > 2) {
              ctx.quadraticCurveTo(
                points[points.length - 2].x,
                points[points.length - 2].y,
                points[points.length - 1].x,
                points[points.length - 1].y
              );
            }
            
            ctx.stroke();
          });
          break;
          
        case 'arrow-tool':
          drawArrowWithOutline(points[0].x, points[0].y, points[1].x, points[1].y, color, lineWidth);
          break;
      }
      
      // ë©”ëª¨ ê·¸ë¦¬ê¸°
      if (memo) {
        const lastPoint = points[points.length - 1];
        // ë©”ëª¨ í…ìŠ¤íŠ¸ì— í°ìƒ‰ í…Œë‘ë¦¬ ì¶”ê°€
        ctx.font = 'bold 14px Noto Sans KR';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        
        // ì¤„ë°”ê¿ˆì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ë©”ëª¨ ë¶„ë¦¬
        const lines = memo.split('\n');
        let lineHeight = 18; // ì¤„ ë†’ì´
        
        lines.forEach((line, index) => {
          ctx.strokeText(line, lastPoint.x + 10, lastPoint.y + 10 + (index * lineHeight));
          ctx.fillStyle = '#000';
          ctx.fillText(line, lastPoint.x + 10, lastPoint.y + 10 + (index * lineHeight));
        });
      }
    }
    
    // í™”ì‚´í‘œ ê·¸ë¦¬ê¸° - í…Œë‘ë¦¬ ì—†ìŒ
    function drawArrow(fromX, fromY, toX, toY, color, width) {
      // í™”ì‚´í‘œ í¬ê¸°ë¥¼ ì„  êµµê¸°ì— ë¹„ë¡€í•˜ê²Œ ì¡°ì •
      const headLength = Math.max(12, width * 5);
      const headWidth = Math.max(8, width * 3);
      const angle = Math.atan2(toY - fromY, toX - fromX);
      
      // ì„  ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.stroke();
      
      // í™”ì‚´í‘œ ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(
        toX - headLength * Math.cos(angle - Math.PI / headWidth),
        toY - headLength * Math.sin(angle - Math.PI / headWidth)
      );
      ctx.lineTo(
        toX - headLength * Math.cos(angle + Math.PI / headWidth),
        toY - headLength * Math.sin(angle + Math.PI / headWidth)
      );
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }
    
    // í™”ì‚´í‘œ ê·¸ë¦¬ê¸° - í°ìƒ‰ í…Œë‘ë¦¬ ì¶”ê°€
    function drawArrowWithOutline(fromX, fromY, toX, toY, color, width) {
      // í™”ì‚´í‘œ í¬ê¸°ë¥¼ ì„  êµµê¸°ì— ë¹„ë¡€í•˜ê²Œ ì¡°ì •
      const headLength = Math.max(12, width * 5);
      const headWidth = Math.max(8, width * 3);
      const angle = Math.atan2(toY - fromY, toX - fromX);
      
      // í°ìƒ‰ í…Œë‘ë¦¬ ì„  ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.strokeStyle = 'white';
      ctx.lineWidth = width + 2; // í…Œë‘ë¦¬ êµµê¸° ê°ì†Œ
      ctx.stroke();
      
      // ì‹¤ì œ ìƒ‰ìƒ ì„  ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.stroke();
      
      // í°ìƒ‰ í…Œë‘ë¦¬ í™”ì‚´í‘œ ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(
        toX - (headLength + 2) * Math.cos(angle - Math.PI / headWidth),
        toY - (headLength + 2) * Math.sin(angle - Math.PI / headWidth)
      );
      ctx.lineTo(
        toX - (headLength + 2) * Math.cos(angle + Math.PI / headWidth),
        toY - (headLength + 2) * Math.sin(angle + Math.PI / headWidth)
      );
      ctx.closePath();
      ctx.fillStyle = 'white';
      ctx.fill();
      
      // ì‹¤ì œ ìƒ‰ìƒ í™”ì‚´í‘œ ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(
        toX - headLength * Math.cos(angle - Math.PI / headWidth),
        toY - headLength * Math.sin(angle - Math.PI / headWidth)
      );
      ctx.lineTo(
        toX - headLength * Math.cos(angle + Math.PI / headWidth),
        toY - headLength * Math.sin(angle + Math.PI / headWidth)
      );
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }
    
    // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    function handleMouseDown(e) {
      // í„°ì¹˜ ì´ë²¤íŠ¸ì¸ì§€ í™•ì¸ (í„°ì¹˜ ê¸°ê¸°ì—ì„œëŠ” ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë„ ë™ì‹œì— ë°œìƒí•  ìˆ˜ ìˆìŒ)
      if (e.type === 'touchstart') return;
      
      isDrawing = true;
      startX = e.offsetX;
      startY = e.offsetY;
      
      points = [];
      points.push({ x: startX, y: startY });
      
      // í˜„ì¬ ê·¸ë¦¬ê¸° ìƒíƒœ ì„¤ì •
      currentDrawingState = {
        type: currentTool,
        color: currentColor,
        lineWidth: currentLineWidth,
        points: points,
        memo: document.getElementById('memo').value
      };
      
      if (currentTool === 'pencil-tool' || currentTool === 'curve-tool') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
      }
    }
    
    function handleMouseMove(e) {
      if (!isDrawing) return;
      
      const x = e.offsetX;
      const y = e.offsetY;
      
      if (currentTool === 'pencil-tool') {
        // ë¨¼ì € í°ìƒ‰ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = 'white';
        ctx.lineWidth = currentLineWidth + 2;
        ctx.lineTo(x, y);
        ctx.stroke();
        
        // ì‹¤ì œ ìƒ‰ìƒìœ¼ë¡œ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.lineTo(x, y);
        ctx.stroke();
        
        points.push({ x, y });
      } else if (currentTool === 'curve-tool') {
        points.push({ x, y });
        
        // ì¼ì‹œì ìœ¼ë¡œ ê³¡ì„  ê·¸ë¦¬ê¸°
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        redrawCanvas();
        
        // í°ìƒ‰ í…Œë‘ë¦¬ ê³¡ì„  ê·¸ë¦¬ê¸°
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        
        for (let i = 1; i < points.length - 2; i++) {
          const xc = (points[i].x + points[i + 1].x) / 2;
          const yc = (points[i].y + points[i + 1].y) / 2;
          ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        
        if (points.length > 2) {
          ctx.quadraticCurveTo(
            points[points.length - 2].x,
            points[points.length - 2].y,
            points[points.length - 1].x,
            points[points.length - 1].y
          );
        }
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = currentLineWidth + 2;
        ctx.stroke();
        
        // ì‹¤ì œ ìƒ‰ìƒ ê³¡ì„  ê·¸ë¦¬ê¸°
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        
        for (let i = 1; i < points.length - 2; i++) {
          const xc = (points[i].x + points[i + 1].x) / 2;
          const yc = (points[i].y + points[i + 1].y) / 2;
          ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        
        if (points.length > 2) {
          ctx.quadraticCurveTo(
            points[points.length - 2].x,
            points[points.length - 2].y,
            points[points.length - 1].x,
            points[points.length - 1].y
          );
        }
        
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.stroke();
      } else {
        // ì¼ì‹œì ìœ¼ë¡œ ë¯¸ë¦¬ë³´ê¸° ê·¸ë¦¬ê¸°
        redrawCanvas();
        
        if (currentTool === 'line-tool') {
          // í°ìƒ‰ í…Œë‘ë¦¬ ì„  ê·¸ë¦¬ê¸°
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = 'white';
          ctx.lineWidth = currentLineWidth + 2;
          ctx.stroke();
          
          // ì‹¤ì œ ìƒ‰ìƒ ì„  ê·¸ë¦¬ê¸°
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = currentColor;
          ctx.lineWidth = currentLineWidth;
          ctx.stroke();
        } else if (currentTool === 'arrow-tool') {
          drawArrowWithOutline(startX, startY, x, y, currentColor, currentLineWidth);
        }
      }
    }
    
    function handleMouseUp(e) {
      if (!isDrawing) return;
      
      const x = e.offsetX;
      const y = e.offsetY;
      
      if (currentTool === 'line-tool' || currentTool === 'arrow-tool') {
        points.push({ x, y });
      }
      
      // ê·¸ë¦¬ê¸° íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
      if (currentDrawingState) {
        drawingHistory.push(currentDrawingState);
      }
      
      isDrawing = false;
      redrawCanvas();
    }
    
    function handleMouseOut() {
      if (isDrawing && currentDrawingState) {
        drawingHistory.push(currentDrawingState);
      }
      
      isDrawing = false;
      redrawCanvas();
    }
    
    // í„°ì¹˜ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    function handleTouchStart(e) {
      if (e.cancelable) {
        e.preventDefault();
      }
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      
      // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ê³ ë ¤í•œ ì¢Œí‘œ ê³„ì‚° (ëª¨ë°”ì¼ì—ì„œ ì •í™•ë„ í–¥ìƒ)
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      
      isDrawing = true;
      startX = x;
      startY = y;
      
      points = [];
      points.push({ x, y });
      
      currentDrawingState = {
        type: currentTool,
        color: currentColor,
        lineWidth: currentLineWidth,
        points: points,
        memo: document.getElementById('memo').value
      };
      
      if (currentTool === 'pencil-tool' || currentTool === 'curve-tool') {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
      }
    }
    
    function handleTouchMove(e) {
      if (e.cancelable) {
        e.preventDefault();
      }
      
      if (!isDrawing) return;
      
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      
      // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ê³ ë ¤í•œ ì¢Œí‘œ ê³„ì‚° (ëª¨ë°”ì¼ì—ì„œ ì •í™•ë„ í–¥ìƒ)
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      
      if (currentTool === 'pencil-tool') {
        // ë¨¼ì € í°ìƒ‰ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = 'white';
        ctx.lineWidth = currentLineWidth + 2;
        ctx.lineTo(x, y);
        ctx.stroke();
        
        // ì‹¤ì œ ìƒ‰ìƒìœ¼ë¡œ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.lineTo(x, y);
        ctx.stroke();
        
        points.push({ x, y });
      } else if (currentTool === 'curve-tool') {
        points.push({ x, y });
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        redrawCanvas();
        
        // í°ìƒ‰ í…Œë‘ë¦¬ ê³¡ì„  ê·¸ë¦¬ê¸°
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        
        for (let i = 1; i < points.length - 2; i++) {
          const xc = (points[i].x + points[i + 1].x) / 2;
          const yc = (points[i].y + points[i + 1].y) / 2;
          ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        
        if (points.length > 2) {
          ctx.quadraticCurveTo(
            points[points.length - 2].x,
            points[points.length - 2].y,
            points[points.length - 1].x,
            points[points.length - 1].y
          );
        }
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = currentLineWidth + 2;
        ctx.stroke();
        
        // ì‹¤ì œ ìƒ‰ìƒ ê³¡ì„  ê·¸ë¦¬ê¸°
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        
        for (let i = 1; i < points.length - 2; i++) {
          const xc = (points[i].x + points[i + 1].x) / 2;
          const yc = (points[i].y + points[i + 1].y) / 2;
          ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        
        if (points.length > 2) {
          ctx.quadraticCurveTo(
            points[points.length - 2].x,
            points[points.length - 2].y,
            points[points.length - 1].x,
            points[points.length - 1].y
          );
        }
        
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.stroke();
      } else {
        redrawCanvas();
        
        if (currentTool === 'line-tool') {
          // í°ìƒ‰ í…Œë‘ë¦¬ ì„  ê·¸ë¦¬ê¸°
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = 'white';
          ctx.lineWidth = currentLineWidth + 2;
          ctx.stroke();
          
          // ì‹¤ì œ ìƒ‰ìƒ ì„  ê·¸ë¦¬ê¸°
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = currentColor;
          ctx.lineWidth = currentLineWidth;
          ctx.stroke();
        } else if (currentTool === 'arrow-tool') {
          drawArrowWithOutline(startX, startY, x, y, currentColor, currentLineWidth);
        }
      }
    }
    
    function handleTouchEnd(e) {
      if (e.cancelable) {
        e.preventDefault();
      }
      
      if (!isDrawing) return;
      
      if (currentTool === 'line-tool' || currentTool === 'arrow-tool') {
        const lastTouch = e.changedTouches[0];
        const rect = canvas.getBoundingClientRect();
        const x = lastTouch.clientX - rect.left;
        const y = lastTouch.clientY - rect.top;
        
        points.push({ x, y });
      }
      
      if (currentDrawingState) {
        drawingHistory.push(currentDrawingState);
      }
      
      isDrawing = false;
      redrawCanvas();
    }
    
    // ìº”ë²„ìŠ¤ ì§€ìš°ê¸°
    function clearCanvas() {
      drawingHistory = [];
      redrawCanvas();
    }
    
    // ì‹¤í–‰ ì·¨ì†Œ
    function undoLastAction() {
      if (drawingHistory.length > 0) {
        drawingHistory.pop();
        redrawCanvas();
      }
    }
    
    // ìº”ë²„ìŠ¤ ì €ì¥
    function saveCanvas() {
      try {
        const dataUrl = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        
        link.href = dataUrl;
        link.download = `í¬ë”ë³´ì»¬_${new Date().toISOString().slice(0, 10)}.png`;
        link.click();
        
        // ëª¨ë°”ì¼ì—ì„œ ì €ì¥ í™•ì¸ ë©”ì‹œì§€
        const isMobile = window.innerWidth <= 768;
        if (isMobile) {
          alert('ì´ë¯¸ì§€ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìš´ë¡œë“œ í´ë”ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
        }
      } catch (err) {
        alert('ì´ë¯¸ì§€ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + err.message);
      }
    }
    
    // ì´ë¯¸ì§€ë§Œ ë‹¤ìš´ë¡œë“œ
    function downloadCanvasImage() {
      // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œë¥¼ ìœ„í•œ ì„ì‹œ ìº”ë²„ìŠ¤ ìƒì„±
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      // ë°°ê²½ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° - ë¹„ìœ¨ ìœ ì§€
      if (backgroundImages[currentBackground] && bgImg.complete) {
        const imgRatio = bgImg.width / bgImg.height;
        const canvasRatio = tempCanvas.width / tempCanvas.height;
        
        let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
        
        if (imgRatio > canvasRatio) {
          drawHeight = tempCanvas.height;
          drawWidth = drawHeight * imgRatio;
          offsetX = (tempCanvas.width - drawWidth) / 2;
        } else {
          drawWidth = tempCanvas.width;
          drawHeight = drawWidth / imgRatio;
          offsetY = (tempCanvas.height - drawHeight) / 2;
        }
        
        tempCtx.drawImage(bgImg, offsetX, offsetY, drawWidth, drawHeight);
      } else {
        // ë°°ê²½ì´ ì—†ìœ¼ë©´ ì—°í•œ ê·¸ë ˆì´ ë°°ê²½
        tempCtx.fillStyle = '#f8f8f8';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      }
      
      // ê·¸ë¦¬ê¸° íˆìŠ¤í† ë¦¬ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
      drawingHistory.forEach(state => {
        // ì„ì‹œì ìœ¼ë¡œ ê·¸ë¦¬ê¸° ìƒíƒœë¥¼ ì„ì‹œ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸° ìœ„í•œ ê¸°ì¡´ ì»¨í…ìŠ¤íŠ¸ ì €ì¥
        const originalContext = ctx;
        ctx = tempCtx;
        drawFromState(state);
        ctx = originalContext;
      });
      
      // ìƒí™© ëª…ì¹­ì„ ìº ë²„ìŠ¤ ìƒë‹¨ì— ê·¸ë¦¬ê¸°
      if (currentSituation) {
        tempCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        tempCtx.fillRect(10, 10, tempCtx.measureText(currentSituation).width + 20, 30);
        tempCtx.font = 'bold 14px Noto Sans KR';
        tempCtx.fillStyle = 'white';
        tempCtx.fillText(currentSituation, 20, 30);
      }
      
      // ì´ë¯¸ì§€ë¡œ ë‹¤ìš´ë¡œë“œ
      const imageUrl = tempCanvas.toDataURL('image/png');
      const link = document.createElement('a');
      
      link.href = imageUrl;
      link.download = `í¬ë”ë³´ì»¬_ì´ë¯¸ì§€_${new Date().toISOString().slice(0, 10)}.png`;
      link.click();
    }
    
    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
    window.addEventListener('load', init);
  </script>
</body>
</html>