<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>í¬ë”ë³´ì»¬ - ë°œì„± ì‹œê°í™” ë„êµ¬</title>
  <style>
    :root {
      --primary-color: #4e54c8;
      --secondary-color: #8f94fb;
      --accent-color: #ff6b6b;
      --background-color: #f9f9f9;
      --panel-color: #ffffff;
      --text-color: #333333;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Noto Sans KR', sans-serif;
      background: var(--background-color);
      color: var(--text-color);
      line-height: 1.6;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      min-height: 100vh;
    }

    header {
      width: 100%;
      max-width: 1000px;
      margin-bottom: 20px;
      text-align: center;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .subtitle {
      font-size: 1.1rem;
      color: #666;
      margin-bottom: 20px;
    }

    .container {
      display: flex;
      width: 100%;
      max-width: 1200px;
      gap: 20px;
    }

    .tools-panel {
      flex: 0 0 300px;
      background: var(--panel-color);
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .tool-section {
      border-bottom: 1px solid #eee;
      padding-bottom: 15px;
    }

    .tool-section:last-child {
      border-bottom: none;
    }

    .section-title {
      font-size: 1.2rem;
      font-weight: 700;
      margin-bottom: 15px;
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-title i {
      font-size: 1.4rem;
    }

    .drawing-tools {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }

    .tool-btn {
      padding: 8px;
      border: 2px solid transparent;
      border-radius: 8px;
      background: #f0f0f0;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 0.9rem;
    }

    .tool-btn i {
      font-size: 1.5rem;
      margin-bottom: 5px;
    }

    .tool-btn:hover {
      background: #e8e8e8;
    }

    .tool-btn.active {
      border-color: var(--primary-color);
      background: rgba(78, 84, 200, 0.1);
    }

    .color-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .color-option {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #eee;
      transition: transform 0.2s;
    }

    .color-option:hover {
      transform: scale(1.15);
    }

    .color-option.active {
      border: 2px solid #333;
      transform: scale(1.15);
    }

    .slider-control {
      margin: 15px 0;
    }

    .slider-control label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .slider-container input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
    }

    .slider-container input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary-color);
      cursor: pointer;
    }

    .slider-value {
      font-weight: 500;
      min-width: 30px;
      text-align: center;
    }

    select {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #f9f9f9;
      font-size: 1rem;
      cursor: pointer;
    }

    .vocal-element {
      margin-top: 10px;
    }

    .vocal-element label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }

    .canvas-container {
      flex: 1;
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }
    
    .situation-display {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-weight: bold;
      z-index: 100;
      max-width: 80%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    #vocalCanvas {
      display: block;
      background: white;
      cursor: crosshair;
      width: 100%;
      height: 100%;
    }

    .action-bar {
      width: 100%;
      max-width: 1200px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn-primary {
      background: var(--primary-color);
      color: white;
    }

    .btn-secondary {
      background: #e9ecef;
      color: #212529;
    }

    .btn-danger {
      background: var(--accent-color);
      color: white;
    }

    .btn:hover {
      opacity: 0.9;
      transform: translateY(-2px);
    }

    .memo-container {
      margin-top: 10px;
    }

    .memo-container textarea {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ddd;
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
    }

    /* ëª¨ë°”ì¼ ë°˜ì‘í˜• */
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      
      .tools-panel {
        flex: none;
        width: 100%;
      }
      
      .canvas-container {
        height: 500px;
      }
    }

    /* ì•„ì´ì½˜ ìŠ¤íƒ€ì¼ */
    .material-icons {
      font-family: 'Material Icons';
      font-weight: normal;
      font-style: normal;
      font-size: 24px;
      line-height: 1;
      letter-spacing: normal;
      text-transform: none;
      display: inline-block;
      white-space: nowrap;
      word-wrap: normal;
      direction: ltr;
      -webkit-font-feature-settings: 'liga';
      -webkit-font-smoothing: antialiased;
    }
  </style>
  <!-- êµ¬ê¸€ í°íŠ¸ ë° ì•„ì´ì½˜ -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
  <header>
    <h1>ğŸµ í¬ë”ë³´ì»¬: ë°œì„± ì‹œê°í™” ë„êµ¬</h1>
    <p class="subtitle">ë°œì„± ì—°ìŠµì„ ìœ„í•œ ì‹œê°ì  ê°€ì´ë“œ ì—ë””í„°</p>
  </header>

  <div class="container">
    <div class="tools-panel">
      <div class="tool-section">
        <div class="section-title">
          <i class="material-icons">brush</i>
          <span>ê·¸ë¦¬ê¸° ë„êµ¬</span>
        </div>
        <div class="drawing-tools">
          <button class="tool-btn active" id="pencil-tool">
            <i class="material-icons">edit</i>
            <span>ì—°í•„</span>
          </button>
          <button class="tool-btn" id="line-tool">
            <i class="material-icons">show_chart</i>
            <span>ì§ì„ </span>
          </button>
          <button class="tool-btn" id="curve-tool">
            <i class="material-icons">timeline</i>
            <span>ê³¡ì„ </span>
          </button>
          <button class="tool-btn" id="arrow-tool">
            <i class="material-icons">arrow_forward</i>
            <span>í™”ì‚´í‘œ</span>
          </button>
        </div>
      </div>

      <div class="tool-section">
        <div class="section-title">
          <i class="material-icons">palette</i>
          <span>ìƒ‰ìƒ ë° ìŠ¤íƒ€ì¼</span>
        </div>
        <div class="color-picker">
          <div class="color-option active" style="background-color: #ff6b6b;" data-color="#ff6b6b"></div>
          <div class="color-option" style="background-color: #4e54c8;" data-color="#4e54c8"></div>
          <div class="color-option" style="background-color: #38d9a9;" data-color="#38d9a9"></div>
          <div class="color-option" style="background-color: #ffd43b;" data-color="#ffd43b"></div>
          <div class="color-option" style="background-color: #ff8787;" data-color="#ff8787"></div>
          <div class="color-option" style="background-color: #7048e8;" data-color="#7048e8"></div>
          <div class="color-option" style="background-color: #000000;" data-color="#000000"></div>
          <div class="color-option" style="background-color: #868e96;" data-color="#868e96"></div>
        </div>

        <div class="slider-control">
          <label>ì„  êµµê¸°</label>
          <div class="slider-container">
            <input type="range" id="line-width" min="1" max="20" value="3">
            <span class="slider-value" id="line-width-value">3px</span>
          </div>
        </div>
      </div>

      <div class="tool-section">
        <div class="section-title">
          <i class="material-icons">category</i>
          <span>ë°œì„± ìš”ì†Œ</span>
        </div>
        
        <div class="vocal-element">
          <label for="vocal-type">ë°œì„± ìœ í˜•</label>
          <select id="vocal-type">
            <option value="default">ì¼ë°˜</option>
            <option value="strength">ê·¼ë ¥ ë°©í–¥</option>
            <option value="sound">ì†Œë¦¬ ë°©í–¥</option>
            <option value="image">ì´ë¯¸ì§€ ë°©í–¥</option>
          </select>
        </div>

        <div class="vocal-element">
          <label for="background-image">ë°°ê²½ ì´ë¯¸ì§€</label>
          <select id="background-image">
            <option value="none">ì—†ìŒ</option>
            <option value="human_vocal">ì¸ì²´ ë°œì„±ê¸°ê´€</option>
            <option value="wave">ìŒíŒŒ íŒ¨í„´</option>
            <option value="notes">ìŒí‘œ</option>
          </select>
        </div>
        
        <div class="vocal-element">
          <label for="situation-title">ìƒí™© ëª…ì¹­</label>
          <input type="text" id="situation-title" placeholder="ìƒí™© ëª…ì¹­ ì…ë ¥ (ì˜ˆ: ê°€ì„± ì—°ìŠµ 1)" />
        </div>

        <div class="memo-container">
          <label for="memo">ë©”ëª¨</label>
          <textarea id="memo" placeholder="ë°œì„± ì—°ìŠµ ë©”ëª¨ë¥¼ ì—¬ê¸°ì— ì‘ì„±í•˜ì„¸ìš”..."></textarea>
        </div>
      </div>
    </div>

    <div class="canvas-container">
      <div class="situation-display" id="situation-display"></div>
      <canvas id="vocalCanvas" width="800" height="600"></canvas>
    </div>
  </div>

  <div class="action-bar">
    <button class="btn btn-danger" id="clear-btn">
      <i class="material-icons">delete</i>
      <span>ì§€ìš°ê¸°</span>
    </button>
    <button class="btn btn-secondary" id="undo-btn">
      <i class="material-icons">undo</i>
      <span>ì‹¤í–‰ì·¨ì†Œ</span>
    </button>
    <button class="btn btn-secondary" id="download-img-btn">
      <i class="material-icons">image</i>
      <span>ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ</span>
    </button>
    <button class="btn btn-primary" id="save-btn">
      <i class="material-icons">save</i>
      <span>ì €ì¥í•˜ê¸°</span>
    </button>
  </div>

  <script>
    // ìº”ë²„ìŠ¤ ë° ì»¨í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
    const canvas = document.getElementById('vocalCanvas');
    const ctx = canvas.getContext('2d');
    
    // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
    function resizeCanvas() {
      const container = document.querySelector('.canvas-container');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      redrawCanvas();
    }

    // ì´ë¯¸ì§€ ë°°ê²½
    const backgroundImages = {
      none: null,
      human_vocal: 'human_vocal.png', 
      wave: 'human_vocal.png', // ì¶”í›„ wave_pattern.pngë¡œ ë³€ê²½
      notes: 'human_vocal.png' // ì¶”í›„ music_notes.pngë¡œ ë³€ê²½
    };
    
    // ë°°ê²½ ì´ë¯¸ì§€ ê°ì²´
    const bgImg = new Image();
    
    // ìƒíƒœ ë³€ìˆ˜
    let isDrawing = false;
    let currentTool = 'pencil-tool';
    let currentColor = '#ff6b6b';
    let currentLineWidth = 3;
    let currentVocalType = 'default';
    let currentBackground = 'none';
    let currentSituation = '';
    let startX, startY;
    let points = []; // ê³¡ì„ ì„ ìœ„í•œ ì ë“¤
    let drawingHistory = [];
    let currentDrawingState = null;
    
    // ì´ˆê¸°í™” í•¨ìˆ˜
    function init() {
      resizeCanvas();
      
      // íˆ´ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelector('.tool-btn.active').classList.remove('active');
          this.classList.add('active');
          currentTool = this.id;
        });
      });
      
      // ìƒ‰ìƒ ì„ íƒ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.querySelectorAll('.color-option').forEach(color => {
        color.addEventListener('click', function() {
          document.querySelector('.color-option.active').classList.remove('active');
          this.classList.add('active');
          currentColor = this.dataset.color;
        });
      });
      
      // ì„  êµµê¸° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      const lineWidthSlider = document.getElementById('line-width');
      const lineWidthValue = document.getElementById('line-width-value');
      
      lineWidthSlider.addEventListener('input', function() {
        currentLineWidth = this.value;
        lineWidthValue.textContent = `${this.value}px`;
      });
      
      // ë°œì„± ìœ í˜• ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.getElementById('vocal-type').addEventListener('change', function() {
        currentVocalType = this.value;
      });
      
      // ë°°ê²½ ì´ë¯¸ì§€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.getElementById('background-image').addEventListener('change', function() {
        currentBackground = this.value;
        if (backgroundImages[currentBackground]) {
          bgImg.src = backgroundImages[currentBackground];
          bgImg.onload = function() {
            redrawCanvas();
          };
        } else {
          redrawCanvas();
        }
      });
      
      // ìƒí™© ëª…ì¹­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.getElementById('situation-title').addEventListener('input', function() {
        currentSituation = this.value;
        updateSituationDisplay();
      });
      
      // ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      document.getElementById('clear-btn').addEventListener('click', clearCanvas);
      document.getElementById('undo-btn').addEventListener('click', undoLastAction);
      document.getElementById('save-btn').addEventListener('click', saveCanvas);
      document.getElementById('download-img-btn').addEventListener('click', downloadCanvasImage);
      
      // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('mouseout', handleMouseOut);
      
      // í„°ì¹˜ ì´ë²¤íŠ¸ ì§€ì›
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
      
      // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸
      window.addEventListener('resize', resizeCanvas);
      
      // ì´ˆê¸° ìº”ë²„ìŠ¤ ì„¤ì •
      clearCanvas();
    }
    
    // ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // ë°°ê²½ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° - ë¹„ìœ¨ ìœ ì§€
      if (backgroundImages[currentBackground] && bgImg.complete) {
        const imgRatio = bgImg.width / bgImg.height;
        const canvasRatio = canvas.width / canvas.height;
        
        let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
        
        if (imgRatio > canvasRatio) {
          // ì´ë¯¸ì§€ê°€ ìº”ë²„ìŠ¤ë³´ë‹¤ ë” ê°€ë¡œë¡œ ê¸´ ê²½ìš°
          drawHeight = canvas.height;
          drawWidth = drawHeight * imgRatio;
          offsetX = (canvas.width - drawWidth) / 2;
        } else {
          // ì´ë¯¸ì§€ê°€ ìº”ë²„ìŠ¤ë³´ë‹¤ ë” ì„¸ë¡œë¡œ ê¸´ ê²½ìš°
          drawWidth = canvas.width;
          drawHeight = drawWidth / imgRatio;
          offsetY = (canvas.height - drawHeight) / 2;
        }
        
        ctx.drawImage(bgImg, offsetX, offsetY, drawWidth, drawHeight);
      }
      
      // ê·¸ë¦¬ê¸° íˆìŠ¤í† ë¦¬ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
      drawingHistory.forEach(state => {
        drawFromState(state);
      });
      
      // ìƒí™© ëª…ì¹­ í‘œì‹œ ì—…ë°ì´íŠ¸
      updateSituationDisplay();
    }
    
    // ìƒí™© ëª…ì¹­ í‘œì‹œ ì—…ë°ì´íŠ¸
    function updateSituationDisplay() {
      const situationDisplay = document.getElementById('situation-display');
      if (currentSituation) {
        situationDisplay.textContent = currentSituation;
        situationDisplay.style.display = 'block';
      } else {
        situationDisplay.style.display = 'none';
      }
    }
    
    // ìƒíƒœì—ì„œ ê·¸ë¦¬ê¸°
    function drawFromState(state) {
      const { type, color, lineWidth, vocalType, points, memo } = state;
      
      // í°ìƒ‰ í…Œë‘ë¦¬ë¥¼ ìœ„í•œ ì„¤ì •
      function drawWithWhiteOutline(drawFunction) {
        // ë¨¼ì € í°ìƒ‰ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = 'white';
        ctx.lineWidth = lineWidth + 2; // í…Œë‘ë¦¬ êµµê¸° ê°ì†Œ
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        drawFunction();
        
        // ê·¸ ìœ„ì— ì‹¤ì œ ìƒ‰ìƒìœ¼ë¡œ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        drawFunction();
      }
      
      switch (type) {
        case 'pencil-tool':
          drawWithWhiteOutline(() => {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
              ctx.lineTo(points[i].x, points[i].y);
            }
            
            ctx.stroke();
          });
          break;
          
        case 'line-tool':
          drawWithWhiteOutline(() => {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[1].x, points[1].y);
            ctx.stroke();
          });
          break;
          
        case 'curve-tool':
          drawWithWhiteOutline(() => {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length - 2; i++) {
              const xc = (points[i].x + points[i + 1].x) / 2;
              const yc = (points[i].y + points[i + 1].y) / 2;
              ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
            }
            
            if (points.length > 2) {
              ctx.quadraticCurveTo(
                points[points.length - 2].x,
                points[points.length - 2].y,
                points[points.length - 1].x,
                points[points.length - 1].y
              );
            }
            
            ctx.stroke();
          });
          break;
          
        case 'arrow-tool':
          drawArrowWithOutline(points[0].x, points[0].y, points[1].x, points[1].y, color, lineWidth);
          break;
      }
      
      // ë©”ëª¨ ê·¸ë¦¬ê¸°
      if (memo) {
        const lastPoint = points[points.length - 1];
        // ë©”ëª¨ í…ìŠ¤íŠ¸ì— í°ìƒ‰ í…Œë‘ë¦¬ ì¶”ê°€
        ctx.font = 'bold 14px Noto Sans KR';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeText(memo, lastPoint.x + 10, lastPoint.y + 10);
        ctx.fillStyle = '#000';
        ctx.fillText(memo, lastPoint.x + 10, lastPoint.y + 10);
      }
      
      // ë°œì„± ìœ í˜• ë§ˆì»¤ ê·¸ë¦¬ê¸°
      if (vocalType !== 'default') {
        drawVocalTypeMarker(points[points.length - 1].x, points[points.length - 1].y, vocalType);
      }
    }
    
    // ë°œì„± ìœ í˜• ë§ˆì»¤ ê·¸ë¦¬ê¸°
    function drawVocalTypeMarker(x, y, type) {
      ctx.save();
      
      switch (type) {
        case 'strength':
          // ê·¼ë ¥ ë°©í–¥ - ì‚¼ê°í˜• ëª¨ì–‘
          // í°ìƒ‰ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
          ctx.beginPath();
          ctx.moveTo(x + 15, y);
          ctx.lineTo(x, y - 10);
          ctx.lineTo(x, y + 10);
          ctx.closePath();
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // ì‹¤ì œ ìƒ‰ìƒ ê·¸ë¦¬ê¸°
          ctx.fillStyle = '#ff6b6b';
          ctx.fill();
          break;
          
        case 'sound':
          // ì†Œë¦¬ ë°©í–¥ - ì› ëª¨ì–‘
          // í°ìƒ‰ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
          ctx.beginPath();
          ctx.arc(x + 15, y, 8, 0, Math.PI * 2);
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // ì‹¤ì œ ìƒ‰ìƒ ê·¸ë¦¬ê¸°
          ctx.fillStyle = '#4e54c8';
          ctx.fill();
          break;
          
        case 'image':
          // ì´ë¯¸ì§€ ë°©í–¥ - ë³„ ëª¨ì–‘
          const spikes = 5;
          const outerRadius = 10;
          const innerRadius = 5;
          
          // í°ìƒ‰ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
          ctx.beginPath();
          for (let i = 0; i < spikes * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius + 2 : innerRadius + 2;
            const angle = Math.PI / spikes * i;
            ctx.lineTo(
              x + 15 + Math.cos(angle) * radius,
              y + Math.sin(angle) * radius
            );
          }
          ctx.closePath();
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // ì‹¤ì œ ìƒ‰ìƒ ê·¸ë¦¬ê¸°
          ctx.beginPath();
          for (let i = 0; i < spikes * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = Math.PI / spikes * i;
            ctx.lineTo(
              x + 15 + Math.cos(angle) * radius,
              y + Math.sin(angle) * radius
            );
          }
          ctx.closePath();
          ctx.fillStyle = '#38d9a9';
          ctx.fill();
          break;
      }
      
      ctx.restore();
    }
    
    // í™”ì‚´í‘œ ê·¸ë¦¬ê¸° - í…Œë‘ë¦¬ ì—†ìŒ
    function drawArrow(fromX, fromY, toX, toY, color, width) {
      // í™”ì‚´í‘œ í¬ê¸°ë¥¼ ì„  êµµê¸°ì— ë¹„ë¡€í•˜ê²Œ ì¡°ì •
      const headLength = Math.max(12, width * 5);
      const headWidth = Math.max(8, width * 3);
      const angle = Math.atan2(toY - fromY, toX - fromX);
      
      // ì„  ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.stroke();
      
      // í™”ì‚´í‘œ ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(
        toX - headLength * Math.cos(angle - Math.PI / headWidth),
        toY - headLength * Math.sin(angle - Math.PI / headWidth)
      );
      ctx.lineTo(
        toX - headLength * Math.cos(angle + Math.PI / headWidth),
        toY - headLength * Math.sin(angle + Math.PI / headWidth)
      );
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }
    
    // í™”ì‚´í‘œ ê·¸ë¦¬ê¸° - í°ìƒ‰ í…Œë‘ë¦¬ ì¶”ê°€
    function drawArrowWithOutline(fromX, fromY, toX, toY, color, width) {
      // í™”ì‚´í‘œ í¬ê¸°ë¥¼ ì„  êµµê¸°ì— ë¹„ë¡€í•˜ê²Œ ì¡°ì •
      const headLength = Math.max(12, width * 5);
      const headWidth = Math.max(8, width * 3);
      const angle = Math.atan2(toY - fromY, toX - fromX);
      
      // í°ìƒ‰ í…Œë‘ë¦¬ ì„  ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.strokeStyle = 'white';
      ctx.lineWidth = width + 2; // í…Œë‘ë¦¬ êµµê¸° ê°ì†Œ
      ctx.stroke();
      
      // ì‹¤ì œ ìƒ‰ìƒ ì„  ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.stroke();
      
      // í°ìƒ‰ í…Œë‘ë¦¬ í™”ì‚´í‘œ ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(
        toX - (headLength + 2) * Math.cos(angle - Math.PI / headWidth),
        toY - (headLength + 2) * Math.sin(angle - Math.PI / headWidth)
      );
      ctx.lineTo(
        toX - (headLength + 2) * Math.cos(angle + Math.PI / headWidth),
        toY - (headLength + 2) * Math.sin(angle + Math.PI / headWidth)
      );
      ctx.closePath();
      ctx.fillStyle = 'white';
      ctx.fill();
      
      // ì‹¤ì œ ìƒ‰ìƒ í™”ì‚´í‘œ ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(
        toX - headLength * Math.cos(angle - Math.PI / headWidth),
        toY - headLength * Math.sin(angle - Math.PI / headWidth)
      );
      ctx.lineTo(
        toX - headLength * Math.cos(angle + Math.PI / headWidth),
        toY - headLength * Math.sin(angle + Math.PI / headWidth)
      );
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }
    
    // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    function handleMouseDown(e) {
      isDrawing = true;
      startX = e.offsetX;
      startY = e.offsetY;
      
      points = [];
      points.push({ x: startX, y: startY });
      
      // í˜„ì¬ ê·¸ë¦¬ê¸° ìƒíƒœ ì„¤ì •
      currentDrawingState = {
        type: currentTool,
        color: currentColor,
        lineWidth: currentLineWidth,
        vocalType: currentVocalType,
        points: points,
        memo: document.getElementById('memo').value
      };
      
      if (currentTool === 'pencil-tool' || currentTool === 'curve-tool') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
      }
    }
    
    function handleMouseMove(e) {
      if (!isDrawing) return;
      
      const x = e.offsetX;
      const y = e.offsetY;
      
      if (currentTool === 'pencil-tool') {
        // ë¨¼ì € í°ìƒ‰ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = 'white';
        ctx.lineWidth = currentLineWidth + 2;
        ctx.lineTo(x, y);
        ctx.stroke();
        
        // ì‹¤ì œ ìƒ‰ìƒìœ¼ë¡œ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.lineTo(x, y);
        ctx.stroke();
        
        points.push({ x, y });
      } else if (currentTool === 'curve-tool') {
        points.push({ x, y });
        
        // ì¼ì‹œì ìœ¼ë¡œ ê³¡ì„  ê·¸ë¦¬ê¸°
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        redrawCanvas();
        
        // í°ìƒ‰ í…Œë‘ë¦¬ ê³¡ì„  ê·¸ë¦¬ê¸°
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        
        for (let i = 1; i < points.length - 2; i++) {
          const xc = (points[i].x + points[i + 1].x) / 2;
          const yc = (points[i].y + points[i + 1].y) / 2;
          ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        
        if (points.length > 2) {
          ctx.quadraticCurveTo(
            points[points.length - 2].x,
            points[points.length - 2].y,
            points[points.length - 1].x,
            points[points.length - 1].y
          );
        }
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = currentLineWidth + 2;
        ctx.stroke();
        
        // ì‹¤ì œ ìƒ‰ìƒ ê³¡ì„  ê·¸ë¦¬ê¸°
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        
        for (let i = 1; i < points.length - 2; i++) {
          const xc = (points[i].x + points[i + 1].x) / 2;
          const yc = (points[i].y + points[i + 1].y) / 2;
          ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        
        if (points.length > 2) {
          ctx.quadraticCurveTo(
            points[points.length - 2].x,
            points[points.length - 2].y,
            points[points.length - 1].x,
            points[points.length - 1].y
          );
        }
        
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.stroke();
      } else {
        // ì¼ì‹œì ìœ¼ë¡œ ë¯¸ë¦¬ë³´ê¸° ê·¸ë¦¬ê¸°
        redrawCanvas();
        
        if (currentTool === 'line-tool') {
          // í°ìƒ‰ í…Œë‘ë¦¬ ì„  ê·¸ë¦¬ê¸°
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = 'white';
          ctx.lineWidth = currentLineWidth + 2;
          ctx.stroke();
          
          // ì‹¤ì œ ìƒ‰ìƒ ì„  ê·¸ë¦¬ê¸°
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = currentColor;
          ctx.lineWidth = currentLineWidth;
          ctx.stroke();
        } else if (currentTool === 'arrow-tool') {
          drawArrowWithOutline(startX, startY, x, y, currentColor, currentLineWidth);
        }
      }
    }
    
    function handleMouseUp(e) {
      if (!isDrawing) return;
      
      const x = e.offsetX;
      const y = e.offsetY;
      
      if (currentTool === 'line-tool' || currentTool === 'arrow-tool') {
        points.push({ x, y });
      }
      
      // ê·¸ë¦¬ê¸° íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
      if (currentDrawingState) {
        drawingHistory.push(currentDrawingState);
      }
      
      isDrawing = false;
      redrawCanvas();
    }
    
    function handleMouseOut() {
      if (isDrawing && currentDrawingState) {
        drawingHistory.push(currentDrawingState);
      }
      
      isDrawing = false;
      redrawCanvas();
    }
    
    // í„°ì¹˜ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    function handleTouchStart(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      
      isDrawing = true;
      startX = x;
      startY = y;
      
      points = [];
      points.push({ x, y });
      
      currentDrawingState = {
        type: currentTool,
        color: currentColor,
        lineWidth: currentLineWidth,
        vocalType: currentVocalType,
        points: points,
        memo: document.getElementById('memo').value
      };
      
      if (currentTool === 'pencil-tool' || currentTool === 'curve-tool') {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
      }
    }
    
    function handleTouchMove(e) {
      e.preventDefault();
      
      if (!isDrawing) return;
      
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      
      if (currentTool === 'pencil-tool') {
        // ë¨¼ì € í°ìƒ‰ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = 'white';
        ctx.lineWidth = currentLineWidth + 2;
        ctx.lineTo(x, y);
        ctx.stroke();
        
        // ì‹¤ì œ ìƒ‰ìƒìœ¼ë¡œ ê·¸ë¦¬ê¸°
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.lineTo(x, y);
        ctx.stroke();
        
        points.push({ x, y });
      } else if (currentTool === 'curve-tool') {
        points.push({ x, y });
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        redrawCanvas();
        
        // í°ìƒ‰ í…Œë‘ë¦¬ ê³¡ì„  ê·¸ë¦¬ê¸°
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        
        for (let i = 1; i < points.length - 2; i++) {
          const xc = (points[i].x + points[i + 1].x) / 2;
          const yc = (points[i].y + points[i + 1].y) / 2;
          ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        
        if (points.length > 2) {
          ctx.quadraticCurveTo(
            points[points.length - 2].x,
            points[points.length - 2].y,
            points[points.length - 1].x,
            points[points.length - 1].y
          );
        }
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = currentLineWidth + 2;
        ctx.stroke();
        
        // ì‹¤ì œ ìƒ‰ìƒ ê³¡ì„  ê·¸ë¦¬ê¸°
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        
        for (let i = 1; i < points.length - 2; i++) {
          const xc = (points[i].x + points[i + 1].x) / 2;
          const yc = (points[i].y + points[i + 1].y) / 2;
          ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        
        if (points.length > 2) {
          ctx.quadraticCurveTo(
            points[points.length - 2].x,
            points[points.length - 2].y,
            points[points.length - 1].x,
            points[points.length - 1].y
          );
        }
        
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentLineWidth;
        ctx.stroke();
      } else {
        redrawCanvas();
        
        if (currentTool === 'line-tool') {
          // í°ìƒ‰ í…Œë‘ë¦¬ ì„  ê·¸ë¦¬ê¸°
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = 'white';
          ctx.lineWidth = currentLineWidth + 2;
          ctx.stroke();
          
          // ì‹¤ì œ ìƒ‰ìƒ ì„  ê·¸ë¦¬ê¸°
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = currentColor;
          ctx.lineWidth = currentLineWidth;
          ctx.stroke();
        } else if (currentTool === 'arrow-tool') {
          drawArrowWithOutline(startX, startY, x, y, currentColor, currentLineWidth);
        }
      }
    }
    
    function handleTouchEnd(e) {
      e.preventDefault();
      
      if (!isDrawing) return;
      
      if (currentTool === 'line-tool' || currentTool === 'arrow-tool') {
        const lastTouch = e.changedTouches[0];
        const rect = canvas.getBoundingClientRect();
        const x = lastTouch.clientX - rect.left;
        const y = lastTouch.clientY - rect.top;
        
        points.push({ x, y });
      }
      
      if (currentDrawingState) {
        drawingHistory.push(currentDrawingState);
      }
      
      isDrawing = false;
      redrawCanvas();
    }
    
    // ìº”ë²„ìŠ¤ ì§€ìš°ê¸°
    function clearCanvas() {
      drawingHistory = [];
      redrawCanvas();
    }
    
    // ì‹¤í–‰ ì·¨ì†Œ
    function undoLastAction() {
      if (drawingHistory.length > 0) {
        drawingHistory.pop();
        redrawCanvas();
      }
    }
    
    // ìº”ë²„ìŠ¤ ì €ì¥
    function saveCanvas() {
      const dataUrl = canvas.toDataURL('image/png');
      const link = document.createElement('a');
      
      link.href = dataUrl;
      link.download = `í¬ë”ë³´ì»¬_${new Date().toISOString().slice(0, 10)}.png`;
      link.click();
    }
    
    // ì´ë¯¸ì§€ë§Œ ë‹¤ìš´ë¡œë“œ
    function downloadCanvasImage() {
      // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œë¥¼ ìœ„í•œ ì„ì‹œ ìº”ë²„ìŠ¤ ìƒì„±
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      // ë°°ê²½ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° - ë¹„ìœ¨ ìœ ì§€
      if (backgroundImages[currentBackground] && bgImg.complete) {
        const imgRatio = bgImg.width / bgImg.height;
        const canvasRatio = tempCanvas.width / tempCanvas.height;
        
        let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
        
        if (imgRatio > canvasRatio) {
          drawHeight = tempCanvas.height;
          drawWidth = drawHeight * imgRatio;
          offsetX = (tempCanvas.width - drawWidth) / 2;
        } else {
          drawWidth = tempCanvas.width;
          drawHeight = drawWidth / imgRatio;
          offsetY = (tempCanvas.height - drawHeight) / 2;
        }
        
        tempCtx.drawImage(bgImg, offsetX, offsetY, drawWidth, drawHeight);
      } else {
        // ë°°ê²½ì´ ì—†ìœ¼ë©´ í°ìƒ‰ ë°°ê²½
        tempCtx.fillStyle = 'white';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      }
      
      // ê·¸ë¦¬ê¸° íˆìŠ¤í† ë¦¬ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
      drawingHistory.forEach(state => {
        // ì„ì‹œì ìœ¼ë¡œ ê·¸ë¦¬ê¸° ìƒíƒœë¥¼ ì„ì‹œ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸° ìœ„í•œ ê¸°ì¡´ ì»¨í…ìŠ¤íŠ¸ ì €ì¥
        const originalContext = ctx;
        ctx = tempCtx;
        drawFromState(state);
        ctx = originalContext;
      });
      
      // ìƒí™© ëª…ì¹­ì„ ìº ë²„ìŠ¤ ìƒë‹¨ì— ê·¸ë¦¬ê¸°
      if (currentSituation) {
        tempCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        tempCtx.fillRect(10, 10, tempCtx.measureText(currentSituation).width + 20, 30);
        tempCtx.font = 'bold 14px Noto Sans KR';
        tempCtx.fillStyle = 'white';
        tempCtx.fillText(currentSituation, 20, 30);
      }
      
      // ì´ë¯¸ì§€ë¡œ ë‹¤ìš´ë¡œë“œ
      const imageUrl = tempCanvas.toDataURL('image/png');
      const link = document.createElement('a');
      
      link.href = imageUrl;
      link.download = `í¬ë”ë³´ì»¬_ì´ë¯¸ì§€_${new Date().toISOString().slice(0, 10)}.png`;
      link.click();
    }
    
    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
    window.addEventListener('load', init);
  </script>
</body>
</html>